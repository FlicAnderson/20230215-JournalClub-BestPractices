---
title: "Journal Club: *Best Practices for Scientific Computing*"
author: "Flic Anderson"
date: "15/02/2023"
output: 
  ioslides_presentation: 
    logo: images/logo.svg
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>

<script>
    $(document).ready(function() {
      $('slide:not(.title-slide, .backdrop, .segue)').append('<footer label=\"BestPracticesSciComp"></footer>');    
    })
</script>

<style>
  footer:after {
    content: attr(label);
    font-size: 12pt;
    position: absolute;
    bottom: 20px;
    left: 100px;
    line-height: 1.9;
  }
</style>

<style type="text/css">
slides > slide:not(.nobackground):after {
  content: '';
}
</style>

<div class="notes">

Bio: 
Currently a PhD Researcher at EPCC, School of Informatics, at the University of Edinburgh, project title: "Coding Smart in Academia: Evidence-Based Software Engineering Approaches for High-Quality Research Software Projects". 
Flic Anderson has been a Research Assistant in Bioinformatics in the Wallace Lab (within the Institute for Cell Biology) at the University of Edinburgh. 
Flic was part of the development team for the 'riboviz' open source software package for processing and analysis of ribosome profiling data, working with colleagues from EPCC (University of Edinburgh) to make the codebase more robust & sustainable.   
With a background in Ecology and Botany (previously a Research Assistant at the Royal Botanic Garden Edinburgh), Flic has worked with a wide range of types of biological data using different software tools and programming languages (particularly R) for the last 8 years, and found herself drawn towards bioinformatics and research software engineering. 
Flic is a member of the Edinburgh Carpentries and a certified Carpentries instructor in foundational coding and data science skills for researchers. 

Title: Best Practices for Scientific Computing 

Abstract:  
Discussion of a key paper in research software engineering which makes recommendations for a set of practices to improve software developed for research, based on authors' experience and teaching, as well as research in the scientific computing and software engineering fields.  
</div>


## HOW TO (RE-)USE THIS MATERIAL

This is a `.html` presentation created in `R Markdown` with `ioslides`. 

(It's been written in a [.Rmd](http://rmarkdown.rstudio.com) file, and I generated .html slides by 'knitting' it in Rstudio.)

You can check out the code used to make these slides at the [Talk repo](https://github.com/FlicAnderson/20230215-JournalClub-BestPractices/) on Github, and adapt it for your own presentations if you like - there's a MIT Licence on the repo, which means: 

*"Basically, you can do whatever you want as long as you include the original copyright and license notice in any copy of the software/source."*

Source: [tl;drLegal](https://tldrlegal.com/license/mit-license)


## Outline 

__Article:__  
- paper format  
- introduction / background / research context  
- Best Practices  
- conclusions
 
__Discussion:__   
- TODO  

__RS: Research software__    
__SE: Software engineering__ 



# The Article 

## Paper Format  

* no abstract / discussion 
* presenting best practice recommendations - these are the key  
* reasonably informal paper  


## introduction / background / research context  

* published 2014  
* RS field back then  
* key papers before this  
* published in PLOS Biology  
* 'scientific computing' vs 'research software'   

<div class="notes"> 
Q: Are YOU a research software engineer / researcher-developer? If you think not, do you write code as part of your research?  

This paper was published in a Biology journal, and mentions 'scientific computing', but it's really widely relevant to all research and research software development.  
</div>


## 
```{r, echo=FALSE,out.width="49%", out.height="20%",fig.cap="'Best Practices for Scientific Computing', [Wilson et al. 2014.](https://doi.org/10.1371/journal.pbio.1001745)",fig.show='hold',fig.align='center'}
knitr::include_graphics(c("images/best-practices-1-to-4.png", "images/best-practices-5-to-8.png"))
```  

## 1. Write programs for people, not computers 
* your code needs to _run_ and be _correct_, but also must be **understandable**  
* _beware memory limits_ in users, not just computers: reduce cognitive load!  
* **break up programs** into _task-oriented functions_ or chunks  
* helpful, **descriptive names** -> self documenting & less confusing  
* **consistent_styling_of_code** -> faster reading, fewer errors  

<div class="notes"> 

These days, people are more memory limited than computers: reduce cognitive load!  

Consistency means errors are easier to spot, humans are great at pattern recognition

This slideshow is written in R Markdown, not Latex, as it's easier for a human (e.g. me) to read the text in a markdown doc than a latex one. Also, fewer slashes required :D
</div>



## 2. Let the computer do the work
* repetitive tasks? _Don't try to be a computer_  
* don't fear the **CLI**     
* commonly repeated commands & tasks -> **scripts**     
* combining scripts? Consider a **Workflow Management System\*** or automated **build tool** like [Make](https://www.gnu.org/software/make/#:~:text=GNU%20Make%20is%20a%20tool,compute%20it%20from%20other%20files.)   
* **store provenance info** (common file formats plz):  
  - raw data IDs, version numbers  
  - _parameter_ values generating specific outputs  
  - _library/program versions_  
* **cite your software!**  

<font size="3">CLI: command line interface; *: WfMS examples: [nextflow](https://www.nextflow.io/), [snakemake](https://snakemake.readthedocs.io/en/stable/)</font>  

<div class="notes"> 
non-computing background folks miss out on 'command history' and repeatability by avoiding CLI :c   

be reproducible - good for research, good for you!  
</div>



## 3. Make incremental changes
* **no 'requirements' available** upfront for RS     
* RS uses an _iterate-improve_ process; similar to Agile development process  
* **keep iterations SHORT** (~1 week), get feedback, improve  
* use a **version control system** e.g. [Git](https://git-scm.com/):   
  - tracks changes & reverts problems (code & data)   
  - solves collaborating issues - locked files, multiple copies, overwrites, etc.  
  - stores metadata and provenance  
* **version control everything you create manually, regenerate the rest** (archive binaries, but store metadata about them with version control!)

<div class="notes"> 

RS isn't similar to 'traditional SE', IS sim to Open Source Software projects & startups re: no requirements from a 'customer'/user often.    
Therefore RS can't apply a lot of requirements-oriented design and development processes.  

Avoid long development without feedback and course checks.  

</div>  



## 4. Don't repeat yourself (or others)
* having **copies of data / 'code clones' is bad**: likely to cause inconsistency, errors, maintenance headaches...  
* _'single authoritative representation in the system'_ means **only one version of a file / variable / ID** that can be updated in ONE PLACE ONLY  
* write IKEA code: **modularity** -> fixable, reusable and easy to keep small 'chunks' in your head (_mental model_ of code) 
* _stand on the shoulders of giants_: **use others' libraries and packages** instead of doing it yourself. 

<div class="notes"> 
...
</div>  



## 5. Plan for mistakes  
* _defensive programming_: **use assertions** in your code: statements which _check inputs/outputs_, document & _explain your code_, and assist in (inevitable) _debugging_   
* run _automated testing_ with **testing libraries**: unit, integration & regression tests!  
* **turn bugs into tests** (prevents silent reappearance of 'fixed' issues) for RS 
* keeping tests in mind -> _more modular and orthogonal* code_  
* **use debuggers**: they help understand and investigate program behaviour (stop/pause, inspect variables, step between levels of function calls)   

<font size="3">*Orthogonality: independence of one variable/concept from another (e.g. editing _function a_ ideally shouldn't require also fixing _function b_) </font>  

<div class="notes"> 
"to err is human", so why are we always surprised when things go wrong? :D   

* run & report _automated testing_ with **testing libraries**:  
  - unit tests for single units of code correctness  
  - integration tests for combining parts of code  
  - regression tests to check whether behaviour stays the same as parts are edited  

* RS might not allow Test-Driven Development because requirements may not exist upfront, so might need different approaches. 


* debuggers: they help understand and investigate program behaviour

</div>  



## 6. Optimise software only after it works correctly
* don't fix imaginary/hypothetical performance bottlenecks - write, then profile THEN fix   
* write high-level code:  
  - it's more time efficient for development per line of code per unit of time   
  - higher-level code is more understandable for others / more self-documenting    
  - prototype in high-level languages for proof of concept/design testing, THEN implement optimised versions in lower level languages like C  
  - test low-level reimplementations against your high-level prototype to test outputs & functionality  
  

<div class="notes"> 
...
</div>  



## 7. Document design and purpose, not mechanics
* RS can be complex - documentation can help share knowledge, reusability, and lower maintenance time/effort     
* what if the code author leaves? (bus factor*!)   
* avoid restating what code does. Instead: why does it do it THIS WAY. Explain design decisions  
* better to **refactor**** than try to explain really complex chunks of code if possible...  
* documentation generators: build docs into the code - avoids code 'outgrowing' docs/docs becoming stale. (Try [Sphinx](https://docs.readthedocs.io/en/stable/intro/getting-started-with-sphinx.html)) 
* "literate programming" - build the code into the docs! (e.g. [Jupyter Notebooks](https://jupyter.org/) for Python+)


<font size="3">*Bus Factor: "how many people on the project have to get hit by a bus before nobody understands the code?" </font>  
<font size="3">**Refactoring: re-writing code to improve understandability without changing its overall behaviour and outputs</font>  

<div class="notes"> 

Refactoring: re-writing code to improve understandability, consistency and general design without changing its overall behaviour and outputs.

Jupyter Notebooks: originally dev'd for Julia, Python & R, but also Haskell, Ruby and probably more. 

</div>  



## 8. Collaborate
* "code review: get other people to read your code to find bugs fast & cheap!" - says decades of research  
* code review spreads knowledge around the project team  
* if you don't need to review before merging code, you probably won't review at all - require it!     
* pair programming: 'driver' + 'navigator' => great for complex coding tasks or onboarding new folks to project  
* use issue tracking (eg. Github) to help team track milestones, task progress, and who is doing what  
* keep in mind that your future self is a collaborator - be nice!  

<div class="notes"> 

* code review spreads knowledge around the project team   

* your future self is a collaborator, as are potential reviewers, supervisors, your future PhD students, peers who'll use your software, your spin-out company, the Nobel Committee etc.  

</div>  


## Conclusions  
* authors collated their experiences and existing research  
* useful for solo coders or multi-dev research software teams  
* benefits:  
  - more productive development of RS  
  - faster results for research  
  - code is more reliable, inspires confidence in results  
  - easier (/actually possible) to reproduce results - good research practice    
* authors advise NOT doing all of these at once if you aren't already - add practices gradually  
* due to overlap between practices, not too insurmountable to adopt  
* reference a [2012 Software Carpentry report](https://software-carpentry.org/files/bib/aranda-assessment-2012-07.pdf) saying the time cost to implement these is offset "almost immediately" by productivity gains 


## Personal Influences
* in undergrad, I got 2% on a programming exam and was told "no use flogging a dead horse"... I didn't code for years after this! ('Not for me')   
* I attended my first Software Carpentry workshop in 2014, first Data Carpentry workshop in 2016   
* came across this paper around then and was inspired by the summary of what I could/should be doing with my research code  
* started moving towards Letting the Computer Do the Work by writing scripts for data manipulation, working with biodiversity data in Research Assistant role, stopped worrying and learned to love the terminal    
* even though I was working solo, I started Writing Programs for People, Not Computers. That person was me, but still...
* by adopting many of these best practices and Making Incremental Changes, I got bioinformatics role on a development team (UoEdinburgh), met EPCC staff   
* started Planning for Mistakes (dipping my toes into testing/debugging), did a lot of Collaboration (developing with 2x US labs and undergrad/masters students) & Documenting Design & Purpose (also helpful for onboarding students and expanding the dev team!).     
* May 2020 trained as a Carpentries Instructor to help spread the Best Practices further  
* started a PhD looking at practices in Research Software Engineering at EPCC in Jan 2022 with Neil Chue Hong (co-author on this paper!)  
* ... (still haven't quite gotten around to Optimising Software Only After It Works Correctly... (though I never write lower-level code ;D))  
* hugely influential!  


# Discussion  

## Questions? 

* Opinions of the paper's 'best practices'? - anything missing?  
* Was it successful?  
* Which is most important to you? Why?  
* Which do you need to do more of? Why? 


## Most important to you?
```{r, echo=FALSE,out.width="44%", out.height="20%",fig.cap="'Best Practices for Scientific Computing', [Wilson et al. 2014.](https://doi.org/10.1371/journal.pbio.1001745)",fig.show='hold',fig.align='center'}
knitr::include_graphics(c("images/best-practices-1-to-4.png", "images/best-practices-5-to-8.png"))
```  

## Need to do more of...?
```{r, echo=FALSE,out.width="44%", out.height="20%",fig.cap="'Best Practices for Scientific Computing', [Wilson et al. 2014.](https://doi.org/10.1371/journal.pbio.1001745)",fig.show='hold',fig.align='center'}
knitr::include_graphics(c("images/best-practices-1-to-4.png", "images/best-practices-5-to-8.png"))
```  





